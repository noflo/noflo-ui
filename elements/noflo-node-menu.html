<link rel="import" href="noflo-new-graph.html">
<polymer-element name="noflo-node-menu" attributes="graph nodes" class="sticky-head the-card-content">
  <template>
    <header>
      <h1>{{ nodes.length}} <template if="{{ nodes.length > 1 }}">Nodes</template><template if="{{ nodes.length == 1 }}">Node</template></h1>
    </header>
    <ul class="toolbar toolbar2right">
      <li><button class="blue-button" on-click="{{ clear }}"><!--i class="fa fa-check"></i-->Deselect</button></li>
      <li><button class="red-button" on-click="{{ remove }}"><!--i class="fa fa-trash-o"></i-->Delete</button></li>
      <li><button class="blue-button" on-click="{{ subgraph }}">Subgraph</button></li>
    </ul>
  </template>
  <script>
    Polymer('noflo-node-menu', {
      graph: null,
      nodes: [],
      clear: function (event) {
        event.preventDefault();
        var node;
        while (this.nodes.length) {
          node = this.nodes.pop();
          node.selected = false;
        }
      },
      remove: function (event) {
        if (event) {
          event.preventDefault();
        }
        var currentGraph = this.graph;
        currentGraph.checkTransactionStart();
        while (this.nodes.length) {
          var node = this.nodes.pop();
          currentGraph.removeNode(node.id);
        }
        currentGraph.checkTransactionEnd();
      },
      /*
      group: function (event) {
        event.preventDefault();
        this.nodes.forEach(function (node) {
        });
      }*/
      subgraph: function (event) {
        event.preventDefault();
        var currentGraph = this.graph;

        // Ask user to name the new subgraph
        var dialog = document.createElement('noflo-new-graph');
        document.body.appendChild(dialog);
        dialog.addEventListener('new', function (event) {
          var graph = event.detail;
          graph.startTransaction('newsubgraph');

          graph.setProperties({
            id: graph.name.replace(' ', '_'),
            project: currentGraph.project
          });

          // Copy nodes
          this.nodes.forEach(function (node) {
            graph.addNode(node.id, node.component, node.metadata);
          });

          // Copy edges between nodes
          currentGraph.edges.forEach(function (edge) {
            if (graph.getNode(edge.from.node) && graph.getNode(edge.to.node)) {
              graph.addEdge(edge.from.node, edge.from.port, edge.to.node, edge.to.port, edge.metadata);
            }
          });

          // Move IIPs to subgraph as well
          currentGraph.initializers.forEach(function (iip) {
            if (graph.getNode(iip.to.node)) {
              graph.addInitial(iip.from.data, iip.to.node, iip.to.port, iip.metadata);
            }
          });

          // Create subgraph node
          var initialMetadata = this.nodes[0].metadata;
          currentGraph.startTransaction('subgraph');
          currentGraph.addNode(graph.properties.id, graph.properties.id, {
            label: graph.name,
            x: initialMetadata.x,
            y: initialMetadata.y
          });

          var subgraphPort = function (node, port) {
            return node.id + '_' + port;
          };

          // Reconnect external edges to subgraph node
          currentGraph.edges.forEach(function (edge) {
            // Edge from outside the new subgraph to a subgraph port
            if (!graph.getNode(edge.from.node) && graph.getNode(edge.to.node)) {
              // Create exported inport
              var inport = subgraphPort(edge.to.node, edge.to.port);
              graph.addInport(inport, edge.to.node, edge.to.port);
              currentGraph.addEdge(edge.from.node, edge.from.port, graph.properties.id, inport);
            }
            // Edge from subgraph port to the outside
            if (graph.getNode(edge.from.node) && !graph.getNode(edge.to.node)) {
              var outport = subgraphPort(edge.from.node, edge.from.port);
              graph.addOutport(outport, edge.from.node, edge.from.port);
              currentGraph.addEdge(graph.properties.id, outport, edge.to.node, edge.to.port);
            }
          });

          // Remove the selected nodes
          this.remove();

          // Emit new subgraph so that it can be stored
          graph.endTransaction('newsubgraph');
          this.fire('newgraph', graph);

          // End the transaction on the main graph
          currentGraph.endTransaction('subgraph');

          console.log(currentGraph, graph);
        }.bind(this));
      }
    });
  </script>
</polymer-element>
